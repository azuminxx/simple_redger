/**
 * „Éá„Éº„ÇøÁµ±Âêà„ÇØ„É©„Çπ
 */
class DataIntegrator {
    constructor() {
        // Êõ¥Êñ∞ÂâçÂèÇÁÖßÁî®„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ: appId(string) -> Map(recordId(string) -> kintoneRecord(object))
        this.recordIndexByApp = new Map();
    }
    /**
     * Áµ±Âêà„Ç≠„Éº„Çí‰Ωø„Å£„Å¶ÂÖ®Âè∞Â∏≥„ÇíÊ§úÁ¥¢
     */
    searchAllLedgersWithIntegrationKeys(originalAppId, originalRecords) {
        // Áµ±Âêà„Ç≠„Éº„ÇíÊäΩÂá∫
        const integrationKeys = this.extractIntegrationKeys(originalRecords);
        
        if (integrationKeys.length === 0) {
            console.log(CONFIG.system.messages.noIntegrationKeys);
            return Promise.resolve([]);
        }

        // Áµ±Âêà„Ç≠„ÉºÊäΩÂá∫„É≠„Ç∞„ÅØÂâäÈô§

        // ÂÖ®Âè∞Â∏≥„ÅÆ„Éá„Éº„Çø„ÇíÊ†ºÁ¥ç„Åô„Çã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        const allLedgerData = {};
        allLedgerData[originalAppId] = originalRecords;

        // ‰ªñ„ÅÆÂè∞Â∏≥„ÇíÊ§úÁ¥¢„Åô„ÇãPromise„Çí‰ΩúÊàêÔºà„É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„ÅØÈô§Â§ñÔºâ
        const searchPromises = [];
        
        Object.keys(CONFIG.apps).forEach(appId => {
            if (appId !== originalAppId) {
                // ‰∏ª„Ç≠„ÉºÊ§úÁ¥¢„ÅÆ„ÅøÂÆüË°å
                const promise = this.searchByPrimaryKeys(appId, integrationKeys)
                    .then(records => {
                        allLedgerData[appId] = records;
                        console.log(`üîç ${CONFIG.apps[appId].name}„ÅÆ‰∏ª„Ç≠„ÉºÊ§úÁ¥¢ÁµêÊûú: ${records.length}‰ª∂`);
                        return records;
                    });
                searchPromises.push(promise);
            }
        });

        // „É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„ÇíBSSID„ÅßÊ§úÁ¥¢„Åô„ÇãPromise„ÇíËøΩÂä†
        const userListPromise = this.searchUserListByUserIds(allLedgerData)
            .then(userListData => {
                // „É¶„Éº„Ç∂„ÉºÂè∞Â∏≥Ê§úÁ¥¢ÁµêÊûú„É≠„Ç∞„ÅØÂâäÈô§
                return userListData;
            });
        searchPromises.push(userListPromise);

        // ÂÖ®„Å¶„ÅÆÊ§úÁ¥¢„ÅåÂÆå‰∫Ü„Åó„Åü„Çâ„Éá„Éº„Çø„ÇíÁµ±Âêà
        return Promise.all(searchPromises)
            .then(async (results) => {
                // ÊúÄÂæå„ÅÆÁµêÊûú„Åå„É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„Éá„Éº„Çø
                const userListData = results.pop();
                // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÊßãÁØâ/Êõ¥Êñ∞
                this.buildOrUpdateRecordIndex(allLedgerData);
                return await this.integrateAllLedgerDataWithUserList(allLedgerData, integrationKeys, userListData);
            });
    }

    /**
     * Áµ±Âêà„Ç≠„Éº„Åã„Çâ‰∏ª„Ç≠„Éº„ÇíÊäΩÂá∫
     */
    parseIntegrationKey(integrationKey) {
        if (!integrationKey || typeof integrationKey !== 'string') {
            return { PC: null, EXT: null, SEAT: null };
        }

        const result = { PC: null, EXT: null, SEAT: null };
        
        // PC:ÂÄ§|EXT:ÂÄ§|SEAT:ÂÄ§ „ÅÆÂΩ¢Âºè„Çí„Éë„Éº„Çπ
        const parts = integrationKey.split('|');
        
        parts.forEach(part => {
            const [key, value] = part.split(':');
            if (key && value && value.trim() !== '') {
                result[key] = value;
            }
        });

        return result;
    }

    /**
     * Ê§úÁ¥¢ÁµêÊûú„ÇíÊõ¥Êñ∞ÂâçÂèÇÁÖßÁî®„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å´ÂèçÊò†
     * ÂΩ¢Âºè: this.recordIndexByApp[appId][recordId] = kintoneRecord
     */
    buildOrUpdateRecordIndex(allLedgerData) {
        if (!allLedgerData) return;
        Object.entries(allLedgerData).forEach(([appId, records]) => {
            const appKey = String(appId);
            if (!this.recordIndexByApp.has(appKey)) {
                this.recordIndexByApp.set(appKey, new Map());
            }
            const map = this.recordIndexByApp.get(appKey);
            (records || []).forEach(record => {
                const recordIdField = record['$id'];
                const recordIdValue = recordIdField && recordIdField.value !== undefined
                    ? String(recordIdField.value)
                    : (record['$id'] ? String(record['$id']) : null);
                if (!recordIdValue) return;
                map.set(recordIdValue, record);
            });
        });
    }

    /**
     * Âçò‰∏Ä„Ç¢„Éó„É™„ÅÆÊ§úÁ¥¢ÁµêÊûú„Çí„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å´ËøΩË®ò
     */
    updateRecordIndexForApp(appId, records) {
        if (!appId || !records) return;
        this.buildOrUpdateRecordIndex({ [String(appId)]: records });
    }

    /**
     * „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åã„ÇâÂÖÉ„É¨„Ç≥„Éº„Éâ„ÇíÂèñÂæó
     */
    getOriginalRecord(appId, recordId) {
        const appKey = String(appId);
        const recKey = String(recordId);
        if (!this.recordIndexByApp || !this.recordIndexByApp.has(appKey)) return null;
        return this.recordIndexByApp.get(appKey).get(recKey) || null;
    }

    /**
     * „Éá„Éê„ÉÉ„Ç∞: „Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÊ¶ÇË¶Å„ÇíÂá∫Âäõ
     */
    debugPrintIndex(appIdFilter = null) {
        try {
            if (!this.recordIndexByApp) {
                console.log('üßæ DataIntegrator: recordIndexByApp Êú™ÂàùÊúüÂåñ');
                return;
            }
            const appIds = appIdFilter ? [String(appIdFilter)] : Array.from(this.recordIndexByApp.keys());
            console.log(`üßæ DataIntegrator: „Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÊ¶ÇË¶Å apps=${appIds.length}`);
            appIds.forEach(appId => {
                const map = this.recordIndexByApp.get(String(appId));
                const ledgerName = (window.CONFIG && window.CONFIG.apps && window.CONFIG.apps[appId]) ? window.CONFIG.apps[appId].name : 'Unknown';
                if (!map) {
                    console.log(`  - appId=${appId}(${ledgerName}): <no entries>`);
                    return;
                }
                const size = map.size;
                const sampleIds = Array.from(map.keys()).slice(0, 5);
                console.log(`  - appId=${appId}(${ledgerName}): ${size}‰ª∂, sampleIds=[${sampleIds.join(', ')}]`);
            });
        } catch (e) {
            console.log('üßæ DataIntegrator: „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÉÄ„É≥„Éó‰∏≠„Å´‰æãÂ§ñ', e);
        }
    }
    /**
     * Áµ±Âêà„Ç≠„Éº„Åã„ÇâÊäΩÂá∫„Åó„Åü‰∏ª„Ç≠„Éº„ÅßÂêÑÂè∞Â∏≥„ÇíÊ§úÁ¥¢ÔºàÂÖ®‰∏ª„Ç≠„Éº„Éï„Ç£„Éº„É´„Éâ„ÇíORÊù°‰ª∂„ÅßÊ§úÁ¥¢Ôºâ
     */
    async searchByPrimaryKeys(appId, integrationKeys) {
        const appConfig = CONFIG.apps[appId];
        if (!appConfig) return [];

        const ledgerName = appConfig.name;
        
        // Áµ±Âêà„Ç≠„Éº„Åã„ÇâÂÖ®„Å¶„ÅÆ‰∏ª„Ç≠„ÉºÂÄ§„ÇíÊäΩÂá∫
        const pcValues = new Set();
        const extValues = new Set();
        const seatValues = new Set();

        integrationKeys.forEach(integrationKey => {
            const parsed = this.parseIntegrationKey(integrationKey);
            
            if (parsed.PC) {
                pcValues.add(parsed.PC);
            }
            if (parsed.EXT) {
                extValues.add(parsed.EXT);
            }
            if (parsed.SEAT) {
                seatValues.add(parsed.SEAT);
            }
        });

        // ORÊù°‰ª∂„ÇØ„Ç®„É™„ÇíÊßãÁØâ
        const queryParts = [];
        
        if (pcValues.size > 0) {
            const pcList = Array.from(pcValues).map(value => `"${value}"`).join(',');
            queryParts.push(`PCÁï™Âè∑ in (${pcList})`);
        }
        
        if (extValues.size > 0) {
            const extList = Array.from(extValues).map(value => `"${value}"`).join(',');
            queryParts.push(`ÂÜÖÁ∑öÁï™Âè∑ in (${extList})`);
        }
        
        if (seatValues.size > 0) {
            const seatList = Array.from(seatValues).map(value => `"${value}"`).join(',');
            queryParts.push(`Â∫ßÂ∏≠Áï™Âè∑ in (${seatList})`);
        }

        if (queryParts.length === 0) {
            return [];
        }

        // ORÊù°‰ª∂„ÅßÁµêÂêà
        const query = queryParts.join(' or ');
        
        return window.searchEngine.searchRecordsWithQuery(appId, query);
    }

    /**
     * 2„Å§„ÅÆÊ§úÁ¥¢ÁµêÊûú„Çí„Éû„Éº„Ç∏ÔºàÈáçË§áÈô§ÂéªÔºâ
     */
    mergeSearchResults(existingRecords, newRecords) {
        if (!existingRecords || existingRecords.length === 0) {
            return newRecords || [];
        }
        
        if (!newRecords || newRecords.length === 0) {
            return existingRecords;
        }

        // Êó¢Â≠ò„É¨„Ç≥„Éº„Éâ„ÅÆID„Çª„ÉÉ„Éà„Çí‰ΩúÊàê
        const existingIds = new Set();
        existingRecords.forEach(record => {
            const recordId = record['$id'] && record['$id'].value !== undefined 
                ? record['$id'].value 
                : record['$id'];
            if (recordId) {
                existingIds.add(recordId);
            }
        });

        // Êñ∞„Åó„ÅÑ„É¨„Ç≥„Éº„Éâ„Åã„ÇâÈáçË§á„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÇÇ„ÅÆ„ÇíËøΩÂä†
        const mergedRecords = [...existingRecords];
        newRecords.forEach(record => {
            const recordId = record['$id'] && record['$id'].value !== undefined 
                ? record['$id'].value 
                : record['$id'];
            
            if (recordId && !existingIds.has(recordId)) {
                mergedRecords.push(record);
                existingIds.add(recordId);
            }
        });

        return mergedRecords;
    }

    /**
     * „É¨„Ç≥„Éº„Éâ„Åã„ÇâÁµ±Âêà„Ç≠„Éº„ÇíÊäΩÂá∫
     */
    extractIntegrationKeys(records) {
        const integrationKeys = new Set();
        
        records.forEach(record => {
            const keyField = record[CONFIG.integrationKey];
            if (keyField && keyField.value) {
                integrationKeys.add(keyField.value);
            }
        });

        return Array.from(integrationKeys);
    }

    /**
     * Áµ±Âêà„Ç≠„Éº„Çí‰Ωø„Å£„Å¶ÁâπÂÆö„ÅÆÂè∞Â∏≥„ÇíÊ§úÁ¥¢
     */
    searchByIntegrationKeys(appId, integrationKeys) {
        // INÊºîÁÆóÂ≠ê„ÅßÁµ±Âêà„Ç≠„Éº„ÅÆÈÖçÂàó„ÇíÊ§úÁ¥¢
        const keyList = integrationKeys.map(key => `"${key}"`).join(',');
        const query = `${CONFIG.integrationKey} in (${keyList})`;
        
        return window.searchEngine.searchRecordsWithQuery(appId, query);
    }

    /**
     * ÂÖ®Âè∞Â∏≥„Åã„ÇâBSSID„ÇíÊäΩÂá∫„Åó„Å¶„É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„ÇíÊ§úÁ¥¢
     */
    searchUserListByUserIds(allLedgerData) {
        const userIds = new Set();
        const userIdFieldName = CONFIG.userList.primaryKey;
        // PCÂè∞Â∏≥„ÅÆappId„ÇíÂèñÂæó
        const pcAppId = Object.keys(CONFIG.apps).find(appId => CONFIG.apps[appId].name === 'PCÂè∞Â∏≥');
        const pcRecords = allLedgerData[pcAppId] || [];
        pcRecords.forEach(record => {
            const userIdField = record[userIdFieldName];
            if (userIdField && userIdField.value) {
                userIds.add(userIdField.value);
            }
        });
        if (userIds.size === 0) {
            return Promise.resolve([]);
        }
        const userIdList = Array.from(userIds).map(id => `"${id}"`).join(',');
        const query = `${userIdFieldName} in (${userIdList})`;
        return window.searchEngine.searchRecordsWithQuery(CONFIG.userList.appId, query);
    }

    /**
     * ÂÖ®Âè∞Â∏≥„ÅÆ„Éá„Éº„Çø„ÇíÁµ±Âêà„Åó„ÄÅ„É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„Åã„ÇâÊ∞èÂêçÊº¢Â≠ó„ÇíÂèñÂæó
     * Áµ±Âêà„Ç≠„Éº„Åß„ÅÆ‰∏ÄËá¥„Å´Èñ¢‰øÇ„Å™„Åè„ÄÅÂÖ®„Å¶„ÅÆÊ§úÁ¥¢ÁµêÊûú„ÇíË°®Á§∫
     */
    async integrateAllLedgerDataWithUserList(allLedgerData, integrationKeys, userListData) {
        const integratedData = [];

        // „É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„ÇíBSSID„Åß„Éû„ÉÉ„ÉóÂåñÔºàCONFIG.js„Åã„ÇâÂèñÂæóÔºâ
        const userIdFieldName = CONFIG.userList.primaryKey;
        //const userNameFieldName = CONFIG.fieldMappings.userName;
        const userListMapFields = CONFIG.userList.mapFields || [];
        const userMaps = {};
        userListMapFields.forEach(fieldName => {
            userMaps[fieldName] = new Map();
        });
        userListData.forEach(user => {
            const userId = user[userIdFieldName] && user[userIdFieldName].value;
            if (userId) {
                userListMapFields.forEach(fieldName => {
                    const value = user[fieldName] && user[fieldName].value;
                    userMaps[fieldName].set(userId, value || '');
                });
            }
        });

        // ÂÖ®Âè∞Â∏≥„ÅÆÂÖ®„É¨„Ç≥„Éº„Éâ„Åã„ÇâÁµ±Âêà„Ç≠„Éº„ÇíÂèéÈõÜ
        const allIntegrationKeys = new Set();
        
        // Ëµ∑ÁÇπÂè∞Â∏≥„ÅÆÁµ±Âêà„Ç≠„Éº
        integrationKeys.forEach(key => allIntegrationKeys.add(key));
        
        // ‰ªñÂè∞Â∏≥„ÅÆÁµ±Âêà„Ç≠„Éº„ÇÇÂèéÈõÜ
        Object.values(allLedgerData).forEach(records => {
            records.forEach(record => {
                const keyField = record[CONFIG.integrationKey];
                if (keyField && keyField.value) {
                    allIntegrationKeys.add(keyField.value);
                }
            });
        });

        // Áµ±Âêà„Ç≠„Éº„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„É¨„Ç≥„Éº„ÉâÁî®„ÅÆ‰∏ÄÊÑè„Ç≠„Éº„ÇíÁîüÊàêÔºàÂ∫ßÂ∏≠Ë°®„Éë„Éº„ÉÑ„ÅØÈô§Â§ñÔºâ
        const recordsWithoutIntegrationKey = [];
        Object.entries(allLedgerData).forEach(([appId, records]) => {
            records.forEach(record => {
                const keyField = record[CONFIG.integrationKey];
                if (!keyField || !keyField.value) {
                    // Â∫ßÂ∏≠Âè∞Â∏≥„ÅÆ„ÄåÂ∫ßÂ∏≠Ë°®„Éë„Éº„ÉÑÔºàÂõ≥ÂΩ¢/„ÉÜ„Ç≠„Çπ„Éà/Á∑öÔºâ„Äç„ÅØÁµ±ÂêàÂØæË±°„Åã„ÇâÈô§Â§ñ
                    try {
                        const ledgerName = (CONFIG.apps && CONFIG.apps[appId] && CONFIG.apps[appId].name) ? CONFIG.apps[appId].name : '';
                        if (ledgerName === 'Â∫ßÂ∏≠Âè∞Â∏≥') {
                            const otField = record['„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁ®ÆÂà•'];
                            const ot = (otField && otField.value !== undefined) ? String(otField.value) : String(otField || '');
                            if (['Âõ≥ÂΩ¢','„ÉÜ„Ç≠„Çπ„Éà','Á∑ö'].includes(ot)) {
                                return; // skip seatmap parts
                            }
                        }
                    } catch (e) { /* noop */ }

                    const recordId = record['$id'] && record['$id'].value !== undefined 
                        ? record['$id'].value 
                        : record['$id'];
                    const uniqueKey = `EMPTY_${appId}_${recordId}`;
                    allIntegrationKeys.add(uniqueKey);
                    recordsWithoutIntegrationKey.push({ key: uniqueKey, appId, record });
                }
            });
        });

        console.log(`üìä Áµ±ÂêàÂá¶ÁêÜÂØæË±°: ${allIntegrationKeys.size}‰ª∂ (Áµ±Âêà„Ç≠„ÉºÊúâ„Çä: ${integrationKeys.length}‰ª∂, Áµ±Âêà„Ç≠„ÉºÁÑ°„Åó: ${recordsWithoutIntegrationKey.length}‰ª∂)`);

        for (const integrationKey of allIntegrationKeys) {
            const integratedRecord = {};
            let recordUserId = null;
            
            for (const [appId, records] of Object.entries(allLedgerData)) {
                const appConfig = CONFIG.apps[appId];
                const ledgerName = appConfig.name;
                const displayFields = CONFIG.getDisplayFields(appId);
                
                let matchingRecord = null;
                
                if (integrationKey.startsWith('EMPTY_')) {
                    // Áµ±Âêà„Ç≠„Éº„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„É¨„Ç≥„Éº„Éâ„ÅÆÂ†¥Âêà
                    const emptyRecord = recordsWithoutIntegrationKey.find(item => 
                        item.key === integrationKey && item.appId === appId
                    );
                    if (emptyRecord) {
                        // Â∫ßÂ∏≠Ë°®„Éë„Éº„ÉÑÔºàÂõ≥ÂΩ¢/„ÉÜ„Ç≠„Çπ„Éà/Á∑öÔºâ„ÅØ„Åì„Åì„Åß„ÇÇÈò≤Ê≥¢Â†§„Å®„Åó„Å¶Èô§Â§ñ
                        try {
                            const ledgerName = (window.CONFIG && window.CONFIG.apps && window.CONFIG.apps[appId]) ? window.CONFIG.apps[appId].name : '';
                            if (ledgerName === 'Â∫ßÂ∏≠Âè∞Â∏≥') {
                                const otField = emptyRecord.record['„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁ®ÆÂà•'];
                                const ot = (otField && otField.value !== undefined) ? String(otField.value) : String(otField || '');
                                if (['Âõ≥ÂΩ¢','„ÉÜ„Ç≠„Çπ„Éà','Á∑ö'].includes(ot)) {
                                    continue; // skip adding this record entirely
                                }
                            }
                        } catch (e) { /* noop */ }
                        matchingRecord = emptyRecord.record;
                    }
                } else {
                    // ÈÄöÂ∏∏„ÅÆÁµ±Âêà„Ç≠„Éº„Åß„ÅÆÊ§úÁ¥¢
                    matchingRecord = records.find(record => {
                        const keyField = record[CONFIG.integrationKey];
                        return keyField && keyField.value === integrationKey;
                    });
                }
                
                if (matchingRecord) {
                    // „É¨„Ç≥„Éº„Éâ„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÄÅdisplayFields„ÅßÊåáÂÆö„Åï„Çå„Åü„Éï„Ç£„Éº„É´„Éâ„ÇíËøΩÂä†
                    displayFields.forEach(fieldCode => {
                        const fieldValue = matchingRecord[fieldCode];
                        const displayValue = fieldValue && fieldValue.value !== undefined 
                            ? fieldValue.value 
                            : fieldValue;
                        
                        integratedRecord[`${ledgerName}_${fieldCode}`] = displayValue;
                        
                        // BSSID„ÇíË®òÈå≤ÔºàCONFIG.js„Åã„ÇâÂèñÂæóÔºâ
                        if (fieldCode === userIdFieldName && displayValue) {
                            recordUserId = displayValue;
                        }
                    });
                    
                    // „É¨„Ç≥„Éº„ÉâID„ÇíËøΩÂä†Ôºà‰øùÂ≠òÂá¶ÁêÜ„Åß‰ΩøÁî®„Åô„Çã„Åü„ÇÅÔºâ
                    const recordIdField = matchingRecord['$id'];
                    const recordIdValue = recordIdField && recordIdField.value !== undefined 
                        ? recordIdField.value 
                        : recordIdField;
                    integratedRecord[`${ledgerName}_$id`] = recordIdValue;
                    
                    // Áµ±Âêà„Ç≠„Éº„ÇÇËøΩÂä†Ôºà„Éû„Éº„Ç∏Âá¶ÁêÜ„Åß‰ΩøÁî®„Åô„Çã„Åü„ÇÅÔºâ
                    const integrationKeyField = matchingRecord[CONFIG.integrationKey];
                    const integrationKeyValue = integrationKeyField && integrationKeyField.value !== undefined 
                        ? integrationKeyField.value 
                        : integrationKeyField;
                    integratedRecord[`${ledgerName}_${CONFIG.integrationKey}`] = integrationKeyValue || integrationKey;
                } else {
                    // „É¨„Ç≥„Éº„Éâ„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÄÅdisplayFields„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Çínull„ÅßÂüã„ÇÅ„Çã
                    displayFields.forEach(fieldCode => {
                        integratedRecord[`${ledgerName}_${fieldCode}`] = null;
                    });
                    
                    // „É¨„Ç≥„Éº„ÉâID„ÇÇnull„ÅßËøΩÂä†
                    integratedRecord[`${ledgerName}_$id`] = null;
                    
                    // Áµ±Âêà„Ç≠„Éº„ÇÇnull„ÅßËøΩÂä†ÔºàEMPTY_„ÅÆÂ†¥Âêà„ÅØÁµ±Âêà„Ç≠„ÉºËá™‰Ωì„ÇÇnullÔºâ
                    integratedRecord[`${ledgerName}_${CONFIG.integrationKey}`] = integrationKey.startsWith('EMPTY_') ? null : null;
                }
            }

            // „É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„Åã„ÇâÊ∞èÂêçÊº¢Â≠óÁ≠â„ÇíÂèñÂæó„Åó„Å¶PCÂè∞Â∏≥„ÅÆ„Éá„Éº„Çø„Å®„Åó„Å¶ÂãïÁöÑ„Å´Ë®≠ÂÆö
            const pcLedgerName = CONFIG.integratedTableConfig.columns.find(c => c.fieldCode === 'PCÁï™Âè∑' && c.primaryKey).ledger;
            if (recordUserId) {
                CONFIG.userList.mapFields.forEach(fieldName => {
                    if (userMaps[fieldName] && userMaps[fieldName].has(recordUserId)) {
                        integratedRecord[`${pcLedgerName}_${fieldName}`] = userMaps[fieldName].get(recordUserId);
                    } else {
                        integratedRecord[`${pcLedgerName}_${fieldName}`] = null;
                    }
                });
            }

            integratedData.push(integratedRecord);
        }

        return integratedData;
    }

    /**
     * 2„Å§„ÅÆÁµ±Âêà„Éá„Éº„Çø„Çí„Éû„Éº„Ç∏ÔºàÈáçË§á„ÇíÈô§Â§ñÔºâ
     * Áµ±Âêà„Ç≠„Éº„ÅåÂêå„Åò„É¨„Ç≥„Éº„Éâ„ÅØÈáçË§á„Å®„Åø„Å™„Åó„ÄÅÊñ∞„Åó„ÅÑ„Éá„Éº„Çø„ÇíÂÑ™ÂÖà
     */
    mergeIntegratedData(existingData, newData) {
        if (!existingData || existingData.length === 0) {
            return newData;
        }
        
        if (!newData || newData.length === 0) {
            return existingData;
        }

        // Êó¢Â≠ò„Éá„Éº„Çø„ÅÆÁµ±Âêà„Ç≠„Éº„Çí„Çª„ÉÉ„Éà„ÅßÁÆ°ÁêÜÔºàÈ´òÈÄüÊ§úÁ¥¢„ÅÆ„Åü„ÇÅÔºâ
        const existingKeys = new Set();
        const mergedData = [...existingData];

        // Êó¢Â≠ò„Éá„Éº„Çø„Åã„ÇâÁµ±Âêà„Ç≠„Éº„ÇíÊäΩÂá∫
        existingData.forEach(record => {
            // Áµ±Âêà„Ç≠„Éº„ÇíÂêÑÂè∞Â∏≥„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Åã„ÇâÊé¢„Åô
            const integrationKey = this.extractIntegrationKeyFromRecord(record);
            if (integrationKey) {
                existingKeys.add(integrationKey);
            }
        });

        // Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„Åã„ÇâÈáçË§á„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÇÇ„ÅÆ„ÇíËøΩÂä†
        newData.forEach(record => {
            const integrationKey = this.extractIntegrationKeyFromRecord(record);
            
            if (integrationKey) {
                // Áµ±Âêà„Ç≠„Éº„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                if (!existingKeys.has(integrationKey)) {
                    mergedData.push(record);
                    existingKeys.add(integrationKey);
                } else {
                    console.log(`‚ùå ÈáçË§á„É¨„Ç≥„Éº„ÉâÈô§Â§ñ: Áµ±Âêà„Ç≠„Éº=${integrationKey}`);
                }
            } else {
                // Áµ±Âêà„Ç≠„Éº„Åånull„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Å®„Çä„ÅÇ„Åà„ÅöËøΩÂä†
                mergedData.push(record);
            }
        });
        
        return mergedData;
    }

    /**
     * Áµ±Âêà„É¨„Ç≥„Éº„Éâ„Åã„ÇâÁµ±Âêà„Ç≠„Éº„ÇíÊäΩÂá∫
     * ÂêÑÂè∞Â∏≥„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Åã„ÇâÁµ±Âêà„Ç≠„Éº„Å´ÂØæÂøú„Åô„ÇãÂÄ§„ÇíÊé¢„Åô
     */
    extractIntegrationKeyFromRecord(record) {
        // ÂêÑÂè∞Â∏≥„Åã„ÇâÁµ±Âêà„Ç≠„Éº„ÇíÊé¢„Åô
        for (const [appId, appConfig] of Object.entries(CONFIG.apps)) {
            const ledgerName = appConfig.name;
            const keyFieldName = `${ledgerName}_${CONFIG.integrationKey}`;
            
            if (record[keyFieldName] && record[keyFieldName] !== null) {
                return record[keyFieldName];
            }
        }
        
        return null;
    }

    /**
     * ‰∏çÊï¥Âêà„Ç≠„ÉºÈõÜÂêà„ÇíÊ§úÂá∫ÔºàPC/ÂÜÖÁ∑ö/Â∫ßÂ∏≠„ÅÆ„ÅÑ„Åö„Çå„Åã„ÅÆ„Ç¢„É≥„Ç´„Éº„ÅßË§áÊï∞„Ç≠„Éº„ÅåÊ∑∑Âú®„Åó„ÄÅ„Åã„Å§Ë§áÊï∞Âè∞Â∏≥„Å´Ë∑®„ÇãÂ†¥ÂêàÔºâ
     * - Êó¢Â≠ò„É°„ÇΩ„ÉÉ„Éâ„ÅØÂ§âÊõ¥„Åõ„Åö„ÄÅ„Åì„Åì„ÅßÁã¨Ëá™„Å´Ê§úÂá∫„É≠„Ç∏„ÉÉ„ÇØ„ÅÆ„ÅøÂÆüË£Ö
     * - „É¨„Ç≥„Éº„Éâ„ÅÆÂÆü„Ç≠„Éº„ÅØ„ÄåÁµ±Âêà„Ç≠„ÉºÔºàÂ≠òÂú®„Åô„Çå„Å∞Ôºâ„Äç‚Üí„Äå„Éï„Ç£„Éº„É´„ÉâÂÄ§„Åã„ÇâÁîüÊàê„Åó„Åü„Ç≠„Éº„Äç„ÅÆÈ†Ü„ÅßÊ±∫ÂÆö
     * @param {Object} allLedgerData appId(string) -> kintoneRecords(array)
     * @returns {Set<string>} inconsistentKeySet ‰∏çÊï¥Âêà„Å®Âà§ÂÆö„Åï„Çå„Åü„Ç≠„ÉºÈõÜÂêà
     */
    findInconsistencyKeySet(allLedgerData) {
        const inconsistent = new Set();
        if (!allLedgerData) return inconsistent;

        const byPC = new Map();   // value -> { keys:Set<string>, ledgers:Set<string> }
        const byEXT = new Map();  // value -> { keys:Set<string>, ledgers:Set<string> }
        const bySEAT = new Map(); // value -> { keys:Set<string>, ledgers:Set<string> }

        const normalize = (v) => {
            const s = (v && typeof v === 'object' && 'value' in v) ? v.value : v;
            if (s === null || s === undefined) return '';
            const t = String(s).trim();
            if (t === '' || t === '-' || t === '„Å™„Åó') return '';
            return t;
        };

        const getEffectiveKey = (record) => {
            const ik = record && record[CONFIG.integrationKey];
            const ikv = (ik && ik.value !== undefined) ? ik.value : ik;
            if (ikv && String(ikv).trim() !== '') return String(ikv).trim();
            const pc = normalize(record && record['PCÁï™Âè∑']);
            const ext = normalize(record && record['ÂÜÖÁ∑öÁï™Âè∑']);
            const seat = normalize(record && record['Â∫ßÂ∏≠Áï™Âè∑']);
            return `PC:${pc}|EXT:${ext}|SEAT:${seat}`;
        };

        const add = (map, key, effectiveKey, ledgerName) => {
            if (!key) return;
            if (!map.has(key)) {
                map.set(key, { keys: new Set(), ledgers: new Set() });
            }
            const entry = map.get(key);
            entry.keys.add(effectiveKey);
            if (ledgerName) entry.ledgers.add(ledgerName);
        };

        // Ëµ∞Êüª„Åó„Å¶„Ç¢„É≥„Ç´„ÉºÂà•„Å´„Ç≠„ÉºÈõÜÂêà„ÇíÊßãÁØâ
        Object.entries(allLedgerData).forEach(([appId, records]) => {
            const appConfig = CONFIG.apps[appId];
            const ledgerName = appConfig ? appConfig.name : '';
            (records || []).forEach(record => {
                const pc = normalize(record['PCÁï™Âè∑']);
                const ext = normalize(record['ÂÜÖÁ∑öÁï™Âè∑']);
                const seat = normalize(record['Â∫ßÂ∏≠Áï™Âè∑']);
                const effKey = getEffectiveKey(record);
                if (pc)  add(byPC, pc, effKey, ledgerName);
                if (ext) add(byEXT, ext, effKey, ledgerName);
                if (seat) add(bySEAT, seat, effKey, ledgerName);
            });
        });

        const collect = (map) => {
            map.forEach(({ keys, ledgers }) => {
                if (keys.size > 1 && ledgers.size >= 2) {
                    keys.forEach(k => inconsistent.add(k));
                }
            });
        };

        collect(byPC);
        collect(byEXT);
        collect(bySEAT);

        return inconsistent;
    }

    /**
     * ÊåáÂÆö„Ç≠„ÉºÈõÜÂêà„Å´Ë©≤ÂΩì„Åô„Çã„É¨„Ç≥„Éº„Éâ„Å†„Åë„ÇíÊÆã„ÅôÔºàÂÖ®Âè∞Â∏≥Ôºâ
     * @param {Object} allLedgerData
     * @param {Set<string>} keySet
     * @returns {Object} filteredAllLedgerData
     */
    filterAllLedgerDataByKeys(allLedgerData, keySet) {
        const normalize = (v) => {
            const s = (v && typeof v === 'object' && 'value' in v) ? v.value : v;
            if (s === null || s === undefined) return '';
            return String(s).trim();
        };
        const getEffectiveKey = (record) => {
            const ik = record && record[CONFIG.integrationKey];
            const ikv = (ik && ik.value !== undefined) ? ik.value : ik;
            if (ikv && String(ikv).trim() !== '') return String(ikv).trim();
            const pc = normalize(record && record['PCÁï™Âè∑']);
            const ext = normalize(record && record['ÂÜÖÁ∑öÁï™Âè∑']);
            const seat = normalize(record && record['Â∫ßÂ∏≠Áï™Âè∑']);
            return `PC:${pc}|EXT:${ext}|SEAT:${seat}`;
        };

        const result = {};
        Object.entries(allLedgerData || {}).forEach(([appId, records]) => {
            result[appId] = (records || []).filter(r => keySet.has(getEffectiveKey(r)));
        });
        return result;
    }

    /**
     * ‰∏çÊï¥ÂêàÂØæË±°„ÅÆ„Åø„ÇíÁµ±Âêà„Åó„ÄÅ„Éê„Éº„ÉÅ„É£„É´„Çπ„ÇØ„É≠„Éº„É´Ë°®Á§∫Áî®„ÅÆÁµ±ÂêàË°åÈÖçÂàó„ÇíËøî„Åô
     * - Êó¢Â≠ò„ÅÆ integrateAllLedgerDataWithUserList „ÇíÂÜçÂà©Áî®
     * @param {Object} allLedgerData
     * @returns {Promise<Array<Object>>}
     */
    async buildInconsistencyIntegratedData(allLedgerData) {
        if (!allLedgerData) return [];
        const keySet = this.findInconsistencyKeySet(allLedgerData);
        if (!keySet || keySet.size === 0) return [];

        // ÂØæË±°„É¨„Ç≥„Éº„Éâ„ÅÆ„ÅøÊÆã„Åô
        const filtered = this.filterAllLedgerDataByKeys(allLedgerData, keySet);

        // „É¶„Éº„Ç∂„ÉºÂè∞Â∏≥„ÇíÂèñÂæó
        const userListData = await this.searchUserListByUserIds(filtered);

        // integrateAllLedgerDataWithUserList „ÅØ allLedgerData ÂÜÖ„ÅÆÂÖ®„Ç≠„Éº„ÅßÁµ±Âêà„Åô„ÇãË®≠Ë®à„ÅÆ„Åü„ÇÅ„ÄÅ
        // „Åì„Åì„Åß allLedgerData „Çí‰∏çÊï¥ÂêàÂØæË±°„ÅÆ„Åø„Å´Áµû„ÇäËæº„Çì„Åß„Åã„ÇâÂëº„Å≥Âá∫„Åô„ÄÇ
        const integrationKeys = Array.from(keySet);
        const integrated = await this.integrateAllLedgerDataWithUserList(filtered, integrationKeys, userListData);

        // ÊúÄÁµÇ„Éï„Ç£„É´„Çø„ÅØ‰∏çË¶Å„ÄÇfiltered „Å´„Çà„Å£„Å¶ÂØæË±°„Ç≠„Éº„Å´Áµû„Çâ„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Åù„ÅÆ„Åæ„ÅæËøî„Åô„ÄÇ
        // ËøΩÂä†: ÊØîËºÉÁî®„Éó„É¨„Éì„É•„Éº„Éï„Ç£„Éº„É´„Éâ„Çí‰ªò‰∏éÔºàÂêÑÂè∞Â∏≥„ÅÆ PCÁï™Âè∑/ÂÜÖÁ∑öÁï™Âè∑/Â∫ßÂ∏≠Áï™Âè∑Ôºâ
        try {
            // ledgerName -> appId „ÅÆÈÄÜÂºï„Åç
            const ledgerToAppId = {};
            Object.entries(CONFIG.apps).forEach(([appId, cfg]) => { ledgerToAppId[cfg.name] = String(appId); });

            const getRawRecordById = (ledgerName, recordId) => {
                const appId = ledgerToAppId[ledgerName];
                if (!appId) return null;
                const list = filtered[appId] || [];
                return list.find(r => {
                    const idField = r['$id'];
                    const idVal = (idField && idField.value !== undefined) ? String(idField.value) : String(idField);
                    return String(recordId) === String(idVal);
                }) || null;
            };

            const take = (raw, fieldCode) => {
                if (!raw) return '';
                const f = raw[fieldCode];
                return (f && f.value !== undefined) ? f.value : (f || '');
            };

            integrated.forEach(row => {
                ['PCÂè∞Â∏≥','ÂÜÖÁ∑öÂè∞Â∏≥','Â∫ßÂ∏≠Âè∞Â∏≥'].forEach(ledger => {
                    const idKey = `${ledger}_$id`;
                    const recId = row[idKey];
                    const raw = recId ? getRawRecordById(ledger, recId) : null;
                    const pc = take(raw, 'PCÁï™Âè∑');
                    const ext = take(raw, 'ÂÜÖÁ∑öÁï™Âè∑');
                    const seat = take(raw, 'Â∫ßÂ∏≠Áï™Âè∑');
                    row[`ÊØîËºÉ_${ledger}_PCÁï™Âè∑`] = pc || '';
                    row[`ÊØîËºÉ_${ledger}_ÂÜÖÁ∑öÁï™Âè∑`] = ext || '';
                    row[`ÊØîËºÉ_${ledger}_Â∫ßÂ∏≠Áï™Âè∑`] = seat || '';
                });
            });
        } catch (e) { /* noop */ }

        return integrated;
    }

    /**
     * ‰∏çÊï¥ÂêàÁµ±ÂêàË°å„Çí„ÄåÈñ¢ÈÄ£ÊÄß„ÅåÈ´ò„ÅÑÈ†Ü„Äç„Å´‰∏¶„ÅπÊõø„Åà„Çã
     * Èñ¢ÈÄ£ÊÄß„ÅÆÂÆöÁæ©: PCÁï™Âè∑ / ÂÜÖÁ∑öÁï™Âè∑ / Â∫ßÂ∏≠Áï™Âè∑„ÅÆ„ÅÑ„Åö„Çå„Åã„ÇíÂÖ±Êúâ„Åô„ÇãË°å„Å©„ÅÜ„Åó„Çí„Å§„Å™„Åê„Ç∞„É©„Éï„ÅÆÈÄ£ÁµêÊàêÂàÜ„ÇíÂ§ß„Åç„ÅÑÈ†Ü
     * Âêå‰∏ÄÊàêÂàÜÂÜÖ„Åß„ÅØ„ÄÅÈö£Êé•„Éé„Éº„ÉâÊï∞ÔºàÈáçË§áÈô§Â§ñÔºâÈôçÈ†Ü ‚Üí Á∞°Êòì„Ç≠„ÉºÊòáÈ†Ü
     * Ë°å„ÅÆ„Ç≠„ÉºÊäΩÂá∫„ÅØ„ÄÅË°åÂÜÖ„ÅÆÂêÑÂè∞Â∏≥„ÅÆ„Äå_<Áµ±Âêà„Ç≠„Éº>„Äç„Çí„Éë„Éº„Çπ„Åó„Å¶ÈõÜÁ¥ÑÔºàPC/EXT/SEAT „ÅÆ„ÅÑ„Åö„Çå„ÅãÔºâ
     * @param {Array<Object>} rows
     * @returns {Array<Object>} ‰∏¶„ÅπÊõø„ÅàÂæå„ÅÆÊñ∞ÈÖçÂàó
     */
    sortIntegratedRowsByRelatedness(rows) {
        if (!Array.isArray(rows) || rows.length === 0) return rows || [];

        // 1) Ë°å„Åî„Å®„ÅÆ„Ç¢„É≥„Ç´„ÉºÈõÜÂêàÔºàpcSet, extSet, seatSetÔºâ„ÇíÊßãÁØâ
        const ledgerNames = Object.values(CONFIG.apps).map(a => a.name);
        const anchors = rows.map(row => {
            const pcSet = new Set();
            const extSet = new Set();
            const seatSet = new Set();

            // Ë°åÂÜÖ„ÅÆÂêÑÂè∞Â∏≥„ÅÆÁµ±Âêà„Ç≠„Éº„Çí„Éë„Éº„Çπ„Åó„Å¶ÈõÜÁ¥Ñ
            ledgerNames.forEach(ledger => {
                const keyField = `${ledger}_${CONFIG.integrationKey}`;
                const ik = row[keyField];
                if (!ik) return;
                const parsed = this.parseIntegrationKey(ik);
                if (parsed.PC) pcSet.add(String(parsed.PC));
                if (parsed.EXT) extSet.add(String(parsed.EXT));
                if (parsed.SEAT) seatSet.add(String(parsed.SEAT));
            });

            // Áõ¥Êé•„Éï„Ç£„Éº„É´„ÉâÔºàË°®Á§∫„Éï„Ç£„Éº„É´„ÉâÔºâ„Åã„Çâ„ÇÇ„Ç¢„É≥„Ç´„Éº„ÇíË£úÂÆå
            const directPC = row['PCÂè∞Â∏≥_PCÁï™Âè∑'];
            if (directPC) pcSet.add(String(directPC));
            const directEXT = row['ÂÜÖÁ∑öÂè∞Â∏≥_ÂÜÖÁ∑öÁï™Âè∑'];
            if (directEXT) extSet.add(String(directEXT));
            const directSEAT = row['Â∫ßÂ∏≠Âè∞Â∏≥_Â∫ßÂ∏≠Áï™Âè∑'];
            if (directSEAT) seatSet.add(String(directSEAT));

            return { pcSet, extSet, seatSet };
        });

        // 2) „Ç¢„É≥„Ç´„ÉºÂÄ§ ‚Üí Ë°å„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÈÄÜÂºï„Åç
        const mapPC = new Map();
        const mapEXT = new Map();
        const mapSEAT = new Map();
        const addIndex = (map, val, idx) => {
            const key = String(val);
            if (!key) return;
            if (!map.has(key)) map.set(key, []);
            map.get(key).push(idx);
        };
        anchors.forEach((a, idx) => {
            a.pcSet.forEach(v => addIndex(mapPC, v, idx));
            a.extSet.forEach(v => addIndex(mapEXT, v, idx));
            a.seatSet.forEach(v => addIndex(mapSEAT, v, idx));
        });

        // 3) Union-Find „ÅßÈÄ£ÁµêÊàêÂàÜÔºàÂÖ±ÊúâPC/EXT/SEAT„Åå„ÅÇ„Çå„Å∞Âêå‰∏Ä„Ç∞„É´„Éº„ÉóÔºâ„ÇíÊßãÁØâ
        const parent = Array(rows.length).fill(0).map((_, i) => i);
        const find = (x) => (parent[x] === x ? x : (parent[x] = find(parent[x])));
        const uniteList = (indices) => {
            if (!indices || indices.length <= 1) return;
            const base = find(indices[0]);
            for (let i = 1; i < indices.length; i++) {
                const r = find(indices[i]);
                if (r !== base) parent[r] = base;
            }
        };
        mapPC.forEach(list => uniteList(list));
        mapEXT.forEach(list => uniteList(list));
        mapSEAT.forEach(list => uniteList(list));

        // 4) ÈÄ£ÁµêÊàêÂàÜ„Åî„Å®„Å´„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÊùü„Å≠„ÇãÔºà‰ª£Ë°®„Ç≠„Éº„ÇÇÁÆóÂá∫Ôºâ
        const simpleKey = (row) => {
            const pc = row['PCÂè∞Â∏≥_PCÁï™Âè∑'] || '';
            const ext = row['ÂÜÖÁ∑öÂè∞Â∏≥_ÂÜÖÁ∑öÁï™Âè∑'] || '';
            const seat = row['Â∫ßÂ∏≠Âè∞Â∏≥_Â∫ßÂ∏≠Áï™Âè∑'] || '';
            return `${pc}\u0001${ext}\u0001${seat}`;
        };

        const groups = new Map(); // root -> indices[]
        for (let i = 0; i < rows.length; i++) {
            const r = find(i);
            if (!groups.has(r)) groups.set(r, []);
            groups.get(r).push(i);
        }

        const groupEntries = Array.from(groups.entries()).map(([root, idxList]) => {
            const rep = [...idxList].sort((a, b) => simpleKey(rows[a]).localeCompare(simpleKey(rows[b])))[0];
            const repKey = simpleKey(rows[rep]);
            return { root, indices: idxList, repKey };
        });

        // 5) „Ç∞„É´„Éº„ÉóÈ†Ü„ÅØ‰ª£Ë°®„Ç≠„Éº„ÅÆÊòáÈ†ÜÔºàÂÆâÂÆöÔºâ
        groupEntries.sort((g1, g2) => g1.repKey.localeCompare(g2.repKey));

        // 6) „Ç∞„É´„Éº„ÉóÂÜÖ„ÅØBFS„ÅßÂ∑°Âõû„Åó„ÄÅ„ÄåÂêå‰∏ÄPC‚ÜíÂêå‰∏ÄEXT‚ÜíÂêå‰∏ÄSEAT„Äç„ÅÆËøëÊé•ÊÄß„ÇíÂÑ™ÂÖà
        const bfsOrderGroup = (idxList) => {
            const visited = new Set();
            const out = [];

            // ‰ª£Ë°®„Éé„Éº„Éâ„Åã„ÇâÈñãÂßãÔºàÊúÄÂ∞èsimpleKeyÔºâ
            const seeds = [...idxList].sort((a, b) => simpleKey(rows[a]).localeCompare(simpleKey(rows[b])));
            for (const seed of seeds) {
                if (visited.has(seed)) continue;
                const queue = [seed];
                visited.add(seed);
                while (queue.length > 0) {
                    const cur = queue.shift();
                    out.push(cur);

                    // Èö£Êé•ÂÄôË£ú„Çí„Ç¢„É≥„Ç´„ÉºÂà•„Å´ÂèéÈõÜÔºàÂêå‰∏ÄPC‚ÜíÂêå‰∏ÄEXT‚ÜíÂêå‰∏ÄSEAT„ÅÆÈ†Ü„ÅßËøΩÂä†Ôºâ
                    const neighOrdered = [];
                    const pushOrderedUnique = (arr, items) => {
                        const seen = new Set(arr);
                        items.forEach(i => { if (!visited.has(i) && !seen.has(i)) { arr.push(i); seen.add(i); } });
                    };

                    // Âêå‰∏ÄPC
                    const pcNeighbors = [];
                    anchors[cur].pcSet.forEach(v => (mapPC.get(v) || []).forEach(j => { if (j !== cur) pcNeighbors.push(j); }));
                    // Âêå‰∏ÄEXT
                    const extNeighbors = [];
                    anchors[cur].extSet.forEach(v => (mapEXT.get(v) || []).forEach(j => { if (j !== cur) extNeighbors.push(j); }));
                    // Âêå‰∏ÄSEAT
                    const seatNeighbors = [];
                    anchors[cur].seatSet.forEach(v => (mapSEAT.get(v) || []).forEach(j => { if (j !== cur) seatNeighbors.push(j); }));

                    // „Åù„Çå„Åû„Çå simpleKey „ÅßÂÆâÂÆöÊï¥ÂàóÂæå„Å´È†ÜÊ¨°ËøΩÂä†
                    pcNeighbors.sort((a, b) => simpleKey(rows[a]).localeCompare(simpleKey(rows[b])));
                    extNeighbors.sort((a, b) => simpleKey(rows[a]).localeCompare(simpleKey(rows[b])));
                    seatNeighbors.sort((a, b) => simpleKey(rows[a]).localeCompare(simpleKey(rows[b])));

                    pushOrderedUnique(neighOrdered, pcNeighbors);
                    pushOrderedUnique(neighOrdered, extNeighbors);
                    pushOrderedUnique(neighOrdered, seatNeighbors);

                    // „Ç≠„É•„ÉºÊäïÂÖ•
                    neighOrdered.forEach(n => { visited.add(n); queue.push(n); });
                }
            }
            return out;
        };

        // 7) ÂêÑ„Ç∞„É´„Éº„Éó„ÅÆBFSÈ†Ü„ÅßÁµêÊûú„ÇíÊßãÁØâ
        const result = [];
        groupEntries.forEach(g => {
            const order = bfsOrderGroup(g.indices);
            order.forEach(i => result.push(rows[i]));
        });
        return result;
    }

    /**
     * ÊåáÂÆöË°å„Å®„ÄåÂêå‰∏ÄPC/ÂÜÖÁ∑ö/Â∫ßÂ∏≠„Äç„ÇíÂÖ±Êúâ„Åô„ÇãÈñ¢ÈÄ£Ë°å„ÇíÁèæÂú®„ÅÆÁµêÊûúÈÖçÂàó„Åã„ÇâÂèéÈõÜ
     * @param {Array<Object>} rows ÁèæÂú®„ÅÆË°®Á§∫„Éá„Éº„ÇøÔºàwindow.tableRenderer.currentSearchResultsÔºâ
     * @param {Object} targetRow Âü∫Ê∫ñË°å
     * @returns {Array<Object>} Èñ¢ÈÄ£Ë°åÔºàÂü∫Ê∫ñË°å„ÇíÂê´„ÇÄÔºâ
     */
    collectRelatedRowsForRow(rows, targetRow) {
        if (!Array.isArray(rows) || !targetRow) return [targetRow].filter(Boolean);

        // „Ç¢„É≥„Ç´„ÉºÊäΩÂá∫„Éò„É´„Éë„Éº
        const extractAnchors = (row) => {
            const pcSet = new Set();
            const extSet = new Set();
            const seatSet = new Set();
            try {
                // Áõ¥Êé•„Éï„Ç£„Éº„É´„Éâ
                const pc = row['PCÂè∞Â∏≥_PCÁï™Âè∑'];
                const ext = row['ÂÜÖÁ∑öÂè∞Â∏≥_ÂÜÖÁ∑öÁï™Âè∑'];
                const seat = row['Â∫ßÂ∏≠Âè∞Â∏≥_Â∫ßÂ∏≠Áï™Âè∑'];
                if (pc) pcSet.add(String(pc));
                if (ext) extSet.add(String(ext));
                if (seat) seatSet.add(String(seat));
                // ÂêÑÂè∞Â∏≥„ÅÆÁµ±Âêà„Ç≠„Éº
                Object.values(CONFIG.apps).forEach(app => {
                    const ledger = app.name;
                    const keyField = `${ledger}_${CONFIG.integrationKey}`;
                    const ik = row[keyField];
                    if (ik) {
                        const parsed = this.parseIntegrationKey(ik);
                        if (parsed.PC) pcSet.add(String(parsed.PC));
                        if (parsed.EXT) extSet.add(String(parsed.EXT));
                        if (parsed.SEAT) seatSet.add(String(parsed.SEAT));
                    }
                });
            } catch (e) { /* noop */ }
            return { pcSet, extSet, seatSet };
        };

        // ÈÄÜÂºï„Åç„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÊßãÁØâ
        const mapPC = new Map();
        const mapEXT = new Map();
        const mapSEAT = new Map();
        const addIndex = (map, v, i) => {
            const key = String(v);
            if (!key) return;
            if (!map.has(key)) map.set(key, []);
            map.get(key).push(i);
        };
        const anchors = rows.map(extractAnchors);
        anchors.forEach((a, i) => {
            a.pcSet.forEach(v => addIndex(mapPC, v, i));
            a.extSet.forEach(v => addIndex(mapEXT, v, i));
            a.seatSet.forEach(v => addIndex(mapSEAT, v, i));
        });

        // Âü∫Ê∫ñË°å„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
        const startIndex = rows.findIndex(r => r === targetRow) >= 0
            ? rows.findIndex(r => r === targetRow)
            : rows.findIndex(r => {
                // fallback: Âêå‰∏ÄÁµ±Âêà„Ç≠„Éº„Åß‰∏ÄËá¥
                if (!r || !targetRow) return false;
                const a = window.virtualScroll?.getRecordIdFromRow?.(r) || '';
                const b = window.virtualScroll?.getRecordIdFromRow?.(targetRow) || '';
                return a === b && a !== '';
            });
        if (startIndex < 0) return [targetRow];

        // BFS„ÅßÈñ¢ÈÄ£Ë°å„ÇíÂèéÈõÜÔºàPC‚ÜíEXT‚ÜíSEAT ÂÑ™ÂÖàÈ†ÜÔºâ
        const visited = new Set([startIndex]);
        const queue = [startIndex];
        const order = [];
        while (queue.length > 0) {
            const cur = queue.shift();
            order.push(cur);
            const pushNeighbors = (list) => {
                (list || []).forEach(i => {
                    if (!visited.has(i)) {
                        visited.add(i);
                        queue.push(i);
                    }
                });
            };
            anchors[cur].pcSet.forEach(v => pushNeighbors(mapPC.get(String(v))));
            anchors[cur].extSet.forEach(v => pushNeighbors(mapEXT.get(String(v))));
            anchors[cur].seatSet.forEach(v => pushNeighbors(mapSEAT.get(String(v))));
        }
        return order.map(i => rows[i]);
    }
}

// „Ç∞„É≠„Éº„Éê„É´„Å´ÂÖ¨Èñã
window.DataIntegrator = DataIntegrator; 